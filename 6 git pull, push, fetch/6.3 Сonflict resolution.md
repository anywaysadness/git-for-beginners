### Разрешение конфликтов в Git

Конфликтом в _**Git**_ называют ситуацию, когда, в ходе слияния изменений (например `git pull/push/merge`) в одном файле, система  
контроля версий не может автоматически решить, какие изменения необходимо сохранить.  

Чаще всего конфликт происходит в ситуациях, когда из одного состояния (коммита) создано несколько веток и в каждой из них  
внесены изменения в один файл без синхронизации с прочими ветками.  

Допустим, существует ветка master со следующей историей:  

<img src="img/ConflictResolutionStart.png" width="100%" height="100%" alt="GitMap">  

Затем, на основании ветки master были созданы ветки branch1 и branch2: 

<img src="img/ConflictResolutionBranch.png" width="100%" height="100%" alt="GitMap">  

После чего, в ветках _**branch1**_ и _**branch2**_ были внесены и закоммичены изменения одного и того же файла (допустим, README.md):  

<img src="img/ConflictResolutionEdit.png" width="100%" height="100%" alt="GitMap">  

При попытке слияния веток _**branch1**_ и _**branch2**_ в _**master**_, первая (по времени слияния) операция пройдет успешно:  

`git checkout branch1`  
`git merge master`  

Добавление изменений в отдельной ветке и слияние - вполне штатная ситуация для git. Однако, если после этого попытаться  
проделать аналогичные действия по слиянию с _**branch2**_, операция завершится с ошибкой:  

```commandline
# Обновление локальной ветки master
git checkout master
git pull

# Попытка слияния branch2 в master
git checkout branch2 
git merge master

Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

Ошибка происходит из-за того, что коммиты _**C3.1**_ и _**C3.2**_ имеют общего прародителя (_**C2**_) и, с точки зрения  
git, изменения в коммитах _**C3.1**_ и _**C3.2**_ абсолютно равноценны.  

Если после этого открыть конфликтные файлы (отмечены как **CONFLICT** в терминале), можно увидеть следующее:  

```commandline
# Содержимое README.md

<<<<<<< HEAD
Changes from branch2
=======
Changes from branch1
>>>>>>> master
```  

При возникновении конфликта, git автоматически добавляет **3 метки**, разделяющие конфликтные ситуации на **2 секции**:
1. между <<<<<<< HEAD и ======= - изменения, которые были внесены в текущей ветке/версии;
2. между ======= и >>>>>>> master - изменения, которые были в ветке master на момент слияния (может быть указан хэш коммита вместо названия ветки).  

### Упрощенное разрешение конфликтов

В случае, когда при конфликте необходимо оставить только одну версию, можно воспользоваться упрощенной процедурой разрешения.  
Для этого, необходимо во всех конфликтных файлах проделать одну из следующих операций:  

```commandline
git checkout --ours README.md # для отклонения всех изменений ветки master во всех конфликтных местах
git checkout --theirs README.md # для отклонения всех изменений текущей ветки во всех конфликтных местах
```  

Для всех файлов с исправленным конфликтом необходимо сделать `git add`, после чего закоммитить и повторить операцию слияния.  

### Ручное разрешение конфликтов  

Ручное разрешение конфликтов подходит в ситуациях, когда необходимы изменения, добавленные во всех конфликтующих ветках.  
Например, если в _**branch1**_ были добавлены стили, а в _**branch2**_ исправлены ошибки текста. Для ручного разрешения конфликта  
необходимо проделать следующее во всех конфликтных файлах (причем конфликт может возникать в нескольких местах одного файла):  
- Удалить метки, которые добавил git;
- Оставить одну, наиболее подходящую версию изменений.

Для всех файлов с исправленным конфликтом необходимо сделать `git add`, после чего закоммитить и повторить операцию слияния.  

В данном примере, конфликт можно было спровоцировать, проделав `git pull branch2` из ветки _**branch1**_ или наоборот.  

Алгоритм разрешения конфликтов в подобной ситуации аналогичен.