# Строение Git

Все принадлежащие гиту файлы проходят через несколько областей:  
1. Рабочая директория (**working directory**);
2. Область/стадия подготовленных файлов или индекс (**staging area**, "стейджинг-зона");
3. Каталог Git (.**git directory**).

<img src="img/StructureGit.png" width="800" height="100%" alt="StructureGit"><br>

**Рабочая директория (working directory)** — это рабочая копия определенной версии нашего проекта, сжатая база данных.  
Здесь находятся файлы, с которыми мы напрямую работаем. Как только мы что-то изменили в этих файлах — изменится  
состояние рабочего каталога (working directory).

**Стадия подготовленных файлов (staging area, индекс)** — это специальная промежуточная область, которую отделяют логически.  
Сюда добавляются файлы, которые будут переданы в каталог Git для отслеживания их версий. В **Staging area** хранятся те  
данные, которые Гит должен будет сохранить (они пойдут в коммит). Это некое среднее состояние между Working Directory и  
.git directory — изменения уже на пути к фиксации, но еще не сохранены в базе Git.  

(Технически **Staging area/Индекс** — это всего лишь файл.)

**Каталог Git (.git directory)** — локальный репозиторий Git — папка .git, в которой Git хранит все объекты и данные нашего  
проекта (и их версии): код, изображения, скрипты, стили. Это хранилище файлов, которые сначала были добавлены в Staging  
area и для них был сделан коммит.

Также здесь Гит хранит свои служебные файлы:

- настройки файла конфигурации репозитория,
- журналы, хранящие операции над репозиторием,
- стадия подготовленных файлов (индекс) — сам файл.

## Перемещение изменений в файлах между областями

<img src="img/MoveInGit.png" width="800" height="100%" alt="MoveInGit"><br>

Изначально мы находимся в рабочей директории **(working directory)**. Это может быть копия версии проекта, склонированная с  
удаленного репозитория, которая находится теперь у нас на жестком диске компьютера. Или это может быть созданный нами  
репозиторий. Суть в том, что это рабочая **директория/каталог**. Здесь мы будем производить все действия по редактированию  
файлов: переписывать код, менять шрифты, цвета, добавлять новые блоки и функции, удалять старые и т.д. В общем, меняем тут  
какие-то файлы, добавляем новые, какие-то удаляем — совершаем те действия/изменения, которые потом хотим сохранить в Git.  

Отредактировали файлы и хотим сохранить эти изменения. Мы не можем напрямую положить их в базу Гита, сначала надо  
переместить изменения в промежуточную область — в Staging area (индекс) — так мы показываем гиту, что эти изменения важны  
и их надо сохранить:  

<img src="img/StageFixes.png" width="40%" height="100%" alt="StageFixes"><br>

"**Stage Fixes**" - Подготовить изменения.  

Добавили изменения в **Staging area**, и теперь необходимо сохранить их в базу Git  — сделать коммит. Мы можем и не делать  
коммит сразу, а поработать еще с файлами в **working directory** и опять добавить их в Индекс. В Индексе собираются  
изменения, которые мы хотим когда-нибудь отправить в коммит.  

Когда мы убедились, что изменения в Индексе хотим сохранить в Git — сделаем коммит:  

<img src="img/Commit.png" width="40%" height="100%" alt="Commit"><br>

"**commit**" — Закоммитить.

Как только мы сделали коммит, изменения в сжатом виде попадают в каталог Git (.git directory) и надежно хранятся в папке  
.git.  

Мы храним изменения в Git для того, чтобы ими когда-нибудь воспользоваться. Поэтому есть команда **checkout**, которая  
позволяет вытащить изменения из каталога Git обратно в рабочую директорию:  

<img src="img/Checkout.png" width="70%" height="100%" alt="Checkout"><br>

В этом и заключается основная задача Git: мы что-то делаем, изменяем и сохраняем все в Гите для того, чтобы когда-нибудь  
мы смогли вытащить обратно в рабочий каталог какую-то из предыдущих версий проекта и работать в ней.

## Состояния (статусы) файлов

Из-за того, что файлы перемещаются по этим трем областям (**working directory**, **staging area** и **.git directory**),  
они могут иметь разные состояния:  

1. **Неотслеживаемые файлы** (**Untracked**) — это все те файлы в нашем рабочем каталоге, о которых Гит ничего не знает.  
Эти файлы не входили в последний коммит и не подготовлены к коммиту.  Когда мы создаем новый репозиторий, Гит ничего  
не хранит, никакие файлы в нем не отслеживает. То же самое с каждым новым файлом в репозитории — Гит не может сразу их  
автоматически подхватить, он просто скажет нам, что видит файлы, но не следит за ними (не хранит их). Для того, чтобы  
Гит их хранил, мы должны их проиндексировать — добавить в **Staging area**.<br><br>
2. **Отслеживаемые файлы** (**tracked**)— это те файлы, о существовании которых гит знает — они находятся под версионным  
контролем. Когда мы впервые клонируем репозиторий, все файлы в нем будут отслеживаемыми и неизмененными, потому что Git  
только что их извлек, и мы ничего пока не редактировали.<br><br>
3. **Измененный** (**Modified**) — как только мы изменим какой-то файл, Git будет рассматривать его как измененный.<br><br>
4. **Индексированный** (**Staged**) — добавленный под версионный контроль гита, помещенный в **Staging area**. В этом статусе  
файл готов к отправке в репозиторий (готов коммиту). Такие файлы находятся уже на пути к фиксации изменений в них, но  
пока эти изменения не сохранены в базе Git. Файлы будут находиться здесь до тех пор, пока мы не сохраним их (не зафиксируем).<br><br>
5. **Зафиксированный** (**Сommitted**) — сохраненный в локальном хранилище, закоммиченный файл, готовый к отправке в  
удаленный репозиторий. Коммитим файл тогда, когда мы уверены, что все изменения, которые мы добавили в **Staging area**,  
необходимо сохранить в базу Git. Они в сжатом виде помещаются в Каталог Git.

Подробнее в главе 3.
___
## Внутреннее устройство Git. Объекты.

Всю информацию Git структурирует и хранит в виде своих "объектов". Это специальные файлы, которые содержат определенную  
информацию о репозитории и его файлах. Все объекты хранятся в папке .git/objects/  и относятся одному из 4-х разных  
типов: "**блоб**", "**дерево**", "**коммит**" или "**таг**".  

1. "**Блоб**" (**blob**) используется для хранения содержимого файла, обычно это большой бинарный файл типа:<br>  
`703ec79a98c1d097d5b1cd320befffa376e826`<br><br>
**Блоб** — это начальное представление данных в Git — один файл на единицу хранения. Он _**формируется для каждого файла**_ в  
репозитории, когда мы добавляем файл в Индекс. Его задача — хранить снимок содержимого файла.<br>  
Если мы просто изменили файл, то Гит еще не начинает его хранить. Но как только мы переводим этот файл в область  
Индекса — вот с этого момента Гит начинает хранить информацию об этом файле.  
Во время добавления файлов в **Индекс** Git делает следующее:<br><br>  
    - сжимает содержимое этих файлов и создает _**блоб-объекты**_;<br><br> 
    - помещает имя этого объекта в файл **_Индекса_** (помним, что технически **_Индекс_** — это всего лишь файл).<br>  
_**Blob-объекты**_ отличаются от файлов тем, что файлы содержат метаданные (например, свое название, информацию о времени  
создания и другие). Если мы перенесем файл из одной папки в другую, эти метаданные не меняются. А _**блоб**_ — это само  
содержимое, представленное в виде бинарных строк данных. Он не хранит ни времени своего создания, ни свое имя, ни любой  
другой информации кроме собственного содержания.<br><br>
2. _**Дерево (tree)**_ - эквивалент директории. Блобы создаются для файлов, а деревья выходят на следующий уровень: они  
показывают связи между файлами. _**Для каждой папки**_ репозитория во время коммита создается свой _**tree-объект**_.<br>  
_**Объект-дерево**_ содержит одну или более записей, указывающей на другое дерево или blob, группу других деревьев или  
блобов. Он показывает, какие файлы и папки лежат в каждой папке репозитория.<br>
_**Объект-дерево**_ формируется для каждой папки репозитория во время коммита.<br><br>
Нужно понимать, что:<br>
   - _**blob-объекты**_ хранят информацию о файлах репозитория и их содержимом;<br><br>
   - _**tree-объекты**_ хранят информацию о расположении этих файлов в репозитории.<br><br>

3. _**Объект коммита**_ - это объект, который содержит информацию о текущем коммите. Он выполняет следующие задачи:<br><br>  
   - указывает на главное дерево (которое содержит корневую папку проекта), фиксируя в истории каким образом оно  
      выглядит в момент выполнения коммита;<br><br> 
   - содержит и мета информацию: кто автора коммита, сообщение и время коммита.<br><br> 
В большинстве случаев коммит также содержит родительские коммиты – предыдущий снэпшот/снэпшоты.<br>  
_**Объект коммита**_, как и объект-дерево формируется во время коммита.<br><br>   
   
4. "_**Таг**_" (_**tag**_) — это способ маркировать определенный коммит как специфический, чтобы впоследствии было легче  
его найти. Маркировать — значит дать какое-либо легко запоминающееся имя.  

Почти все в Git построено вокруг манипуляций этой простой структурой, состоящей из четырех различных объектов. И если мы  
на время забудем о кодовых репозиториях Git, а вместо этого представим Git как систему, которая поддерживает файловую  
организацию, то нам будет проще понять Git. Это что-то вроде своеобразной системы, надстроенной над файловой системой  
компьютера, и ее задача — сделать снимок (снэпшот, коммит) файловой системы в определенные моменты времени.  

**Итог:**  

Файловая система начинается с корневой папки (директории), которая обозначается слэшем:

`/`  

Она содержит в себе файлы и другие папки, которые в свою очередь содержат в себе разные папки и файлы. Внутри Git  
содержимое файлов хранится в blob-объектах. Объекты деревья показывают связи между файлами в репозитории. А коммит  
фиксирует в истории проекта как выглядит главное дерево в момент выполнения коммита.  

Таким образом, хранение данных репозитория в Git выстроено следующим образом:  

<img src="img/GitStructure.jpg" width="100%" height="100%" alt="GitStructure"><br>

В объекте коммита хранится tree-объект, который указывает на главное дерево - Корневую папку. Для того, чтобы указывать  
на репозиторий, коммит должен указывать именно на корневую папку репозитория.  

Для самой **Корневой папки** создается объект-дерево, в котором будут перечисляться все компоненты, которые есть в папке:  
1. Вложенный объект-дерево для Подпапки 1;
2. Блоб для Файла 2;
3. Блоб для Файла 3.

Для Подпапки 1 тоже создастся свой tree-объект, внутри которого лежт блоб-объект для **Файла 1**.  
___

## Имена объектов в Индексе 

Итак, во время добавления файла в индекс Git сжимает содержимое этого файла и создает блоб-объект. Git также записывает  
имя блоба в индекс, которое является его идентификатором. Поговорим подробнее об имени, которое Git дает этому блобу.  

Для обеспечения целостности данных Git использует специальные имена — SHA-1 хэши. Это контрольная хэш-сумма содержимого  
и заголовка объекта, уникальный идентификатор для каждого объекта. Подробнее о SHA-1 [тут](https://ru.wikipedia.org/wiki/SHA-1).  
Вкратце нужно запомнить, что у всех **Git-объектов** есть уникальные **хеш-номера**, закодированные алгоритмом SHA1.  

Каждому blob-объекту Git присваивает имя — SHA-1 хэш. Эта 40-значная строка и будет единицей хранения файла в  
репозитории гита. Первые два символа SHA определяют подкаталог файла, остальные 38 — имя. Эти идентификаторы  
используются для перемещения по временной шкале коммитов и возвращения к коммитам.  

Объекты-деревья также идентифицируются SHA-1 хэшами. SHA-1 хэш дерева будет ссылаться на внутренние блобы и деревья  
(файлы, которые лежат в данной папке, и другие поддиректории), использую SHA-1 хэши этих объектов.  

SHA-1 хэши служат в качестве ссылок, чтобы одни объекты могли ссылаться на другие объекты, формируя тем самым дерево.  
И в итоге все объекты ссылаются друг на друга с помощью хэшей. Git интерпретирует структуру директорий проекта, как  
дерево состоящие из blob- и tree-объектов, связанных между собой хеш-ссылками, а коммит ссылается на корень дерева.  

Сам хэш можно посмотреть в репозитории:  

```commandline
$ find .git/objects
.git/objects/27/703ec79a98c1d097d5b1cd320befffa376e826
```

Данный объект `27703ec79a98c1d097d5b1cd320befffa376e826` и есть SHA-1 хэш. Он хранит снимок содержимого определенного  
файла.  

Коммиты тоже идентифицируются своими собственными SHA-1 хэшами. Хэши коммитов мы увидим, когда будем использовать  
команду git log (забегая вперед, данная команда выводит все снэпшоты и позволяет фильтровать историю проекта).  

С помощью SHA-1 хэшей Git работает надежно и достаточно быстро. Git любит эти 40-значные строки: они сводят возможность  
найти два разных объекта с одинаковым именем практически к нулю. Сравнив имена объектов, Git сразу определит, идентичны  
ли сами объекты. Кроме того, раз имена объектов вычисляются одинаково во всех репозиториях, то объекты с одинаковым  
содержимым в двух репозиториях всегда будут хранится под одинаковыми именами. И конечно же, Git найдет ошибки когда  
читает объект, сравнив хэш значение содержимого объекта с его именем.
___

## Итог

### I. Базовые концепции Git

1. **Remote Git repository** – удаленный репозиторий Git. У нас есть удаленный сервер, который мы называем  Git repository. Мы со  
своего локального компьютера можем с этим репозиторием "общаться" – что-то туда заливать, что-то оттуда скачивать.  
Работать с этим репозиторием может сколько угодно разработчиков.<br>  
GitHub (GitLab) предоставляет графическую часть, с помощью которой мы можем комфортно работать с удаленным репозиторием.<br><br>
2. **Local Git repository** – локальная копия кода. Есть код в удаленном репозитории, мы его получаем себе локально и работаем  
с ним локально.<br><br>  
3. **History** – история изменения кода. Базовый концепт любой VCS, без которого система контроля версий просто не имеет  
смысла.<br>  
Любое изменения приводит к образованию новой версии, и мы можем перемещаться из одной версии в другую в  
зависимости от нужд разработки.<br><br>   
4. **Staging** – изменения, которые нужно зафиксировать локально (changes to commit).<br><br>  
5. **Git client** – Git-клиент – некая сущность, с помощью которой мы можем оперировать с Гитом – для выполнения Git-команд.  

### II. Строение Git

1. Git — распределенная система контроля версий, позволяющая сохранять изменения, внесённые в файлы, которые хранятся  
в репозитории.<br><br>
2. Git хранит все файлы и связи между ними, как объекты (=файлы с определенной информацией о репозитории)<br><br>
3. Все файлы проходят через несколько секций: рабочий каталог (**working directory**), область подготовленных файлов или  
индекс (**staging area**) и локальный git-каталог (**.git directory**). Только потом они отправляются на сервер в удаленный  
репозиторий (**remote git repository**):  

<img src="img/GitSection.png" width="100%" height="100%" alt="GitSection"><br>

4. Working directory — рабочий каталог, содержит файлы, с которыми мы работаем напрямую.<br><br> 
5. Staging area (индекс) — нужна Git, чтобы понимать, какие из файлов мы добавим в последующий коммит, а какие – нет.<br><br>  
6. Всю информацию Git структурирует в виде своих объектов:<br><br> 
   * блоб (хранит содержимое файла),<br><br> 
   * дерево (показывает связь между файлами),<br><br> 
   * коммит (содержит указатель на главное дерево и мета информацию),<br><br> 
   * таг (маркировка коммита).<br><br>  
7. Каждому объекту Git присваивает идентификаторы — SHA-1 хэши, с помощью которых Git обеспечивает порядок. Они  
служат в качестве ссылок, чтобы одни объекты могли ссылаться на другие объекты, формируя тем самым дерево. Git  
интерпретирует структуру директорий проекта, как дерево состоящие из blob- и tree-объектов, связанных между собой хеш-  
линками, а коммит ссылается на корневое дерева.